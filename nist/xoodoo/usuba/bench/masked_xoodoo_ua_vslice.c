/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/xoodoo/usuba/ua/xoodoo.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "MASKED.h"

/* auxiliary functions */
void theta__V32 (/*inputs*/ DATATYPE A__[3][4][MASKING_ORDER], /*outputs*/ DATATYPE R__[3][4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE E__[4][MASKING_ORDER];
  DATATYPE P__[4][MASKING_ORDER];
  DATATYPE _tmp1_[4][MASKING_ORDER];
  DATATYPE _tmp2_[MASKING_ORDER];
  DATATYPE _tmp3_[MASKING_ORDER];

  // Instructions (body)
  XOR(_tmp1_[0],A__[0][0],A__[1][0]);
  XOR(_tmp1_[1],A__[0][1],A__[1][1]);
  XOR(_tmp1_[2],A__[0][2],A__[1][2]);
  XOR(_tmp1_[3],A__[0][3],A__[1][3]);
  XOR(P__[0],_tmp1_[0],A__[2][0]);
  XOR(P__[1],_tmp1_[1],A__[2][1]);
  XOR(P__[2],_tmp1_[2],A__[2][2]);
  XOR(P__[3],_tmp1_[3],A__[2][3]);
  for (int i__ = 0; i__ <= 3; i__++) {
    L_ROTATE(_tmp2_,P__[((i__ + 3) % 4)],5,32);
    L_ROTATE(_tmp3_,P__[((i__ + 3) % 4)],14,32);
    XOR(E__[i__],_tmp2_,_tmp3_);
  }
  for (int i__ = 0; i__ <= 2; i__++) {
    XOR(R__[i__][0],A__[i__][0],E__[0]);
    XOR(R__[i__][1],A__[i__][1],E__[1]);
    XOR(R__[i__][2],A__[i__][2],E__[2]);
    XOR(R__[i__][3],A__[i__][3],E__[3]);
  }

}

void rho_west__V32 (/*inputs*/ DATATYPE A__[3][4][MASKING_ORDER], /*outputs*/ DATATYPE R__[3][4][MASKING_ORDER]) {

  // Variables declaration
  ;

  // Instructions (body)
  ASGN(R__[0][0],A__[0][0]);
  ASGN(R__[0][1],A__[0][1]);
  ASGN(R__[0][2],A__[0][2]);
  ASGN(R__[0][3],A__[0][3]);
  ASGN(R__[1][0],A__[1][3]);
  ASGN(R__[1][1],A__[1][0]);
  ASGN(R__[1][2],A__[1][1]);
  ASGN(R__[1][3],A__[1][2]);
  for (int i__ = 0; i__ <= 3; i__++) {
    L_ROTATE(R__[2][i__],A__[2][i__],11,32);
  }

}

void iota__V32 (/*inputs*/ DATATYPE A__[3][4][MASKING_ORDER],DATATYPE rc__[MASKING_ORDER], /*outputs*/ DATATYPE R__[3][4][MASKING_ORDER]) {

  // Variables declaration
  ;

  // Instructions (body)
  XOR(R__[0][0],A__[0][0],rc__);
  ASGN(R__[0][1],A__[0][1]);
  ASGN(R__[0][2],A__[0][2]);
  ASGN(R__[0][3],A__[0][3]);
  ASGN(R__[1][0],A__[1][0]);
  ASGN(R__[1][1],A__[1][1]);
  ASGN(R__[1][2],A__[1][2]);
  ASGN(R__[1][3],A__[1][3]);
  ASGN(R__[2][0],A__[2][0]);
  ASGN(R__[2][1],A__[2][1]);
  ASGN(R__[2][2],A__[2][2]);
  ASGN(R__[2][3],A__[2][3]);

}

void chi__V32 (/*inputs*/ DATATYPE A__[3][4][MASKING_ORDER], /*outputs*/ DATATYPE R__[3][4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE B__[3][4][MASKING_ORDER];
  DATATYPE _tmp4_[4][MASKING_ORDER];
  DATATYPE _tmp5_[4][MASKING_ORDER];
  DATATYPE _tmp6_[4][MASKING_ORDER];

  // Instructions (body)
  NOT(_tmp4_[0],A__[1][0]);
  NOT(_tmp4_[1],A__[1][1]);
  NOT(_tmp4_[2],A__[1][2]);
  NOT(_tmp4_[3],A__[1][3]);
  AND(B__[0][0],_tmp4_[0],A__[2][0]);
  AND(B__[0][1],_tmp4_[1],A__[2][1]);
  AND(B__[0][2],_tmp4_[2],A__[2][2]);
  AND(B__[0][3],_tmp4_[3],A__[2][3]);
  NOT(_tmp5_[0],A__[2][0]);
  NOT(_tmp5_[1],A__[2][1]);
  NOT(_tmp5_[2],A__[2][2]);
  NOT(_tmp5_[3],A__[2][3]);
  AND(B__[1][0],_tmp5_[0],A__[0][0]);
  AND(B__[1][1],_tmp5_[1],A__[0][1]);
  AND(B__[1][2],_tmp5_[2],A__[0][2]);
  AND(B__[1][3],_tmp5_[3],A__[0][3]);
  NOT(_tmp6_[0],A__[0][0]);
  NOT(_tmp6_[1],A__[0][1]);
  NOT(_tmp6_[2],A__[0][2]);
  NOT(_tmp6_[3],A__[0][3]);
  AND(B__[2][0],_tmp6_[0],A__[1][0]);
  AND(B__[2][1],_tmp6_[1],A__[1][1]);
  AND(B__[2][2],_tmp6_[2],A__[1][2]);
  AND(B__[2][3],_tmp6_[3],A__[1][3]);
  XOR(R__[0][0],A__[0][0],B__[0][0]);
  XOR(R__[0][1],A__[0][1],B__[0][1]);
  XOR(R__[0][2],A__[0][2],B__[0][2]);
  XOR(R__[0][3],A__[0][3],B__[0][3]);
  XOR(R__[1][0],A__[1][0],B__[1][0]);
  XOR(R__[1][1],A__[1][1],B__[1][1]);
  XOR(R__[1][2],A__[1][2],B__[1][2]);
  XOR(R__[1][3],A__[1][3],B__[1][3]);
  XOR(R__[2][0],A__[2][0],B__[2][0]);
  XOR(R__[2][1],A__[2][1],B__[2][1]);
  XOR(R__[2][2],A__[2][2],B__[2][2]);
  XOR(R__[2][3],A__[2][3],B__[2][3]);

}

void rho_east__V32 (/*inputs*/ DATATYPE A__[3][4][MASKING_ORDER], /*outputs*/ DATATYPE R__[3][4][MASKING_ORDER]) {

  // Variables declaration
  ;

  // Instructions (body)
  ASGN(R__[0][0],A__[0][0]);
  ASGN(R__[0][1],A__[0][1]);
  ASGN(R__[0][2],A__[0][2]);
  ASGN(R__[0][3],A__[0][3]);
  for (int i__ = 0; i__ <= 3; i__++) {
    L_ROTATE(R__[1][i__],A__[1][i__],1,32);
  }
  for (int i__ = 0; i__ <= 3; i__++) {
    L_ROTATE(R__[2][i__],A__[2][((i__ + 2) % 4)],8,32);
  }

}

void round__V32 (/*inputs*/ DATATYPE state__[3][4][MASKING_ORDER],DATATYPE rc__[MASKING_ORDER], /*outputs*/ DATATYPE stateR__[3][4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp10_[3][4][MASKING_ORDER];
  DATATYPE _tmp7_[3][4][MASKING_ORDER];
  DATATYPE _tmp8_[3][4][MASKING_ORDER];
  DATATYPE _tmp9_[3][4][MASKING_ORDER];

  // Instructions (body)
  theta__V32(state__,_tmp7_);
  rho_west__V32(_tmp7_,_tmp8_);
  iota__V32(_tmp8_,rc__,_tmp9_);
  chi__V32(_tmp9_,_tmp10_);
  rho_east__V32(_tmp10_,stateR__);

}

/* main function */
void xoodoo__ (/*inputs*/ DATATYPE input__[3][4][MASKING_ORDER], /*outputs*/ DATATYPE output__[3][4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE RC__[12][MASKING_ORDER];
  DATATYPE state__[3][4][MASKING_ORDER];

  // Instructions (body)
  ASGN_CST(RC__[0], LIFT_32(88));
  ASGN_CST(RC__[1], LIFT_32(56));
  ASGN_CST(RC__[2], LIFT_32(960));
  ASGN_CST(RC__[3], LIFT_32(208));
  ASGN_CST(RC__[4], LIFT_32(288));
  ASGN_CST(RC__[5], LIFT_32(20));
  ASGN_CST(RC__[6], LIFT_32(96));
  ASGN_CST(RC__[7], LIFT_32(44));
  ASGN_CST(RC__[8], LIFT_32(896));
  ASGN_CST(RC__[9], LIFT_32(240));
  ASGN_CST(RC__[10], LIFT_32(416));
  ASGN_CST(RC__[11], LIFT_32(18));
  ASGN(state__[0][0],input__[0][0]);
  ASGN(state__[0][1],input__[0][1]);
  ASGN(state__[0][2],input__[0][2]);
  ASGN(state__[0][3],input__[0][3]);
  ASGN(state__[1][0],input__[1][0]);
  ASGN(state__[1][1],input__[1][1]);
  ASGN(state__[1][2],input__[1][2]);
  ASGN(state__[1][3],input__[1][3]);
  ASGN(state__[2][0],input__[2][0]);
  ASGN(state__[2][1],input__[2][1]);
  ASGN(state__[2][2],input__[2][2]);
  ASGN(state__[2][3],input__[2][3]);
  for (int i__ = 0; i__ <= 11; i__++) {
    round__V32(state__,RC__[i__],state__);
  }
  ASGN(output__[0][0],state__[0][0]);
  ASGN(output__[0][1],state__[0][1]);
  ASGN(output__[0][2],state__[0][2]);
  ASGN(output__[0][3],state__[0][3]);
  ASGN(output__[1][0],state__[1][0]);
  ASGN(output__[1][1],state__[1][1]);
  ASGN(output__[1][2],state__[1][2]);
  ASGN(output__[1][3],state__[1][3]);
  ASGN(output__[2][0],state__[2][0]);
  ASGN(output__[2][1],state__[2][1]);
  ASGN(output__[2][2],state__[2][2]);
  ASGN(output__[2][3],state__[2][3]);

}

/* Additional functions */
uint32_t bench_speed() {
  /* inputs */
  DATATYPE input__[3][4][MASKING_ORDER] = { 0 };
  /* outputs */
  DATATYPE output__[3][4][MASKING_ORDER] = { 0 };
  /* fun call */
  xoodoo__(input__,output__);

  /* Returning the number of encrypted bytes */
  return 48;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 node theta(A :  u32[3][4] :: base)
  returns R :  u32[3][4] :: base
vars
  P :  u32[4] :: base,
  E :  u32[4] :: base
let
  (P) = ((A[0] ^ A[1]) ^ A[2]);
  forall i in [0,3] {
    (E[i]) = ((P[((i + 3) % 4)] <<< 5) ^ (P[((i + 3) % 4)] <<< 14))
  };
  forall i in [0,2] {
    (R[i]) = (A[i] ^ E)
  }
tel

 node rho_west(A :  u32[3][4] :: base)
  returns R :  u32[3][4] :: base
vars

let
  (R[0]) = A[0];
  (R[1]) = (A[1] >>> 1);
  forall i in [0,3] {
    (R[2][i]) = (A[2][i] <<< 11)
  }
tel

 node iota(A :  u32[3][4] :: base,rc :  u32 :: base)
  returns R :  u32[3][4] :: base
vars

let
  (R[0][0]) = (A[0][0] ^ rc);
  (R[0][1 .. 3]) = A[0][1 .. 3];
  (R[1,2]) = A[1,2]
tel

 node chi(A :  u32[3][4] :: base)
  returns R :  u32[3][4] :: base
vars
  B :  u32[3][4] :: base
let
  (B[0]) = ((~ A[1]) & A[2]);
  (B[1]) = ((~ A[2]) & A[0]);
  (B[2]) = ((~ A[0]) & A[1]);
  (R) = (A ^ B)
tel

 node rho_east(A :  u32[3][4] :: base)
  returns R :  u32[3][4] :: base
vars

let
  (R[0]) = A[0];
  forall i in [0,3] {
    (R[1][i]) = (A[1][i] <<< 1)
  };
  forall i in [0,3] {
    (R[2][i]) = (A[2][((i + 2) % 4)] <<< 8)
  }
tel

 node round(state :  u32[3][4] :: base,rc :  u32 :: base)
  returns stateR :  u32[3][4] :: base
vars

let
  (stateR) = rho_east(chi(iota(rho_west(theta(state)),rc)))
tel

 node xoodoo(input :  u32[3][4] :: base)
  returns output :  u32[3][4] :: base
vars
  state :  u32[13][3][4] :: base,
  RC :  u32[12] :: base
let
  (RC) = (88,56,960,208,288,20,96,44,896,240,416,18);
  (state[0]) = input;
  forall i in [0,11] {
    (state[(i + 1)]) = round(state[i],RC[i])
  };
  (output) = state[12]
tel

*/
 