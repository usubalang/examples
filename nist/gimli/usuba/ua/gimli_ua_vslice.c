/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/gimli/usuba/ua/gimli.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */
#define NO_RUNTIME

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */
void SPbox__V32 (/*inputs*/ DATATYPE col__0__,DATATYPE col__1__,DATATYPE col__2__, /*outputs*/ DATATYPE* colR__0__,DATATYPE* colR__1__,DATATYPE* colR__2__) {
  
  // Variables declaration
  DATATYPE _tmp10_;
  DATATYPE _tmp1_;
  DATATYPE _tmp2_;
  DATATYPE _tmp3_;
  DATATYPE _tmp4_;
  DATATYPE _tmp5_;
  DATATYPE _tmp6_;
  DATATYPE _tmp7_;
  DATATYPE _tmp8_;
  DATATYPE _tmp9_;
  DATATYPE x__;
  DATATYPE y__;

  // Instructions (body)
  x__ = L_ROTATE(col__0__,24,32);
  y__ = L_ROTATE(col__1__,9,32);
  _tmp1_ = L_SHIFT(col__2__,1,32);
  _tmp2_ = XOR(x__,_tmp1_);
  _tmp3_ = AND(y__,col__2__);
  _tmp4_ = L_SHIFT(_tmp3_,2,32);
  *colR__2__ = XOR(_tmp2_,_tmp4_);
  _tmp5_ = XOR(y__,x__);
  _tmp6_ = OR(x__,col__2__);
  _tmp7_ = L_SHIFT(_tmp6_,1,32);
  *colR__1__ = XOR(_tmp5_,_tmp7_);
  _tmp8_ = XOR(col__2__,y__);
  _tmp9_ = AND(x__,y__);
  _tmp10_ = L_SHIFT(_tmp9_,3,32);
  *colR__0__ = XOR(_tmp8_,_tmp10_);

}

void NonlinearLayer__V32 (/*inputs*/ DATATYPE state__[3][4], /*outputs*/ DATATYPE stateR__[3][4]) {
  
  // Variables declaration
  ;

  // Instructions (body)
  for (int i__ = 0; i__ <= 3; i__++) {
    SPbox__V32(state__[0][i__],state__[1][i__],state__[2][i__],&stateR__[0][i__],&stateR__[1][i__],&stateR__[2][i__]);
  }

}

void SmallSwap__V32 (/*inputs*/ DATATYPE state__[3][4], /*outputs*/ DATATYPE stateR__[3][4]) {
  
  // Variables declaration
  ;

  // Instructions (body)
  stateR__[0][0] = state__[0][1];
  stateR__[0][1] = state__[0][0];
  stateR__[0][2] = state__[0][3];
  stateR__[0][3] = state__[0][2];
  stateR__[1][0] = state__[1][0];
  stateR__[1][1] = state__[1][1];
  stateR__[1][2] = state__[1][2];
  stateR__[1][3] = state__[1][3];
  stateR__[2][0] = state__[2][0];
  stateR__[2][1] = state__[2][1];
  stateR__[2][2] = state__[2][2];
  stateR__[2][3] = state__[2][3];

}

void BigSwap__V32 (/*inputs*/ DATATYPE state__[3][4], /*outputs*/ DATATYPE stateR__[3][4]) {
  
  // Variables declaration
  ;

  // Instructions (body)
  stateR__[0][0] = state__[0][2];
  stateR__[0][1] = state__[0][3];
  stateR__[0][2] = state__[0][0];
  stateR__[0][3] = state__[0][1];
  stateR__[1][0] = state__[1][0];
  stateR__[1][1] = state__[1][1];
  stateR__[1][2] = state__[1][2];
  stateR__[1][3] = state__[1][3];
  stateR__[2][0] = state__[2][0];
  stateR__[2][1] = state__[2][1];
  stateR__[2][2] = state__[2][2];
  stateR__[2][3] = state__[2][3];

}

void AddRC__V32 (/*inputs*/ DATATYPE state__[3][4],DATATYPE rc__, /*outputs*/ DATATYPE stateR__[3][4]) {
  
  // Variables declaration
  DATATYPE _tmp11_;

  // Instructions (body)
  _tmp11_ = XOR(state__[0][0],rc__);
  stateR__[0][0] = _tmp11_;
  stateR__[0][1] = state__[0][1];
  stateR__[0][2] = state__[0][2];
  stateR__[0][3] = state__[0][3];
  stateR__[1][0] = state__[1][0];
  stateR__[1][1] = state__[1][1];
  stateR__[1][2] = state__[1][2];
  stateR__[1][3] = state__[1][3];
  stateR__[2][0] = state__[2][0];
  stateR__[2][1] = state__[2][1];
  stateR__[2][2] = state__[2][2];
  stateR__[2][3] = state__[2][3];

}

/* main function */
void gimli__ (/*inputs*/ DATATYPE state__[3][4], /*outputs*/ DATATYPE stateR__[3][4]) {
  
  // Variables declaration
  DATATYPE _tmp12_[3][4];
  DATATYPE rc__[6];
  DATATYPE round__[37][3][4];

  // Instructions (body)
  round__[0][0][0] = state__[0][0];
  round__[0][0][1] = state__[0][1];
  round__[0][0][2] = state__[0][2];
  round__[0][0][3] = state__[0][3];
  round__[0][1][0] = state__[1][0];
  round__[0][1][1] = state__[1][1];
  round__[0][1][2] = state__[1][2];
  round__[0][1][3] = state__[1][3];
  round__[0][2][0] = state__[2][0];
  round__[0][2][1] = state__[2][1];
  round__[0][2][2] = state__[2][2];
  round__[0][2][3] = state__[2][3];
  rc__[0] = LIFT_32(2654435608);
  rc__[1] = LIFT_32(2654435604);
  rc__[2] = LIFT_32(2654435600);
  rc__[3] = LIFT_32(2654435596);
  rc__[4] = LIFT_32(2654435592);
  rc__[5] = LIFT_32(2654435588);
  for (int r__ = 0; r__ <= 5; r__++) {
    NonlinearLayer__V32(round__[(r__ * 6)],round__[((r__ * 6) + 1)]);
    SmallSwap__V32(round__[((r__ * 6) + 1)],_tmp12_);
    AddRC__V32(_tmp12_,rc__[r__],round__[((r__ * 6) + 2)]);
    NonlinearLayer__V32(round__[((r__ * 6) + 2)],round__[((r__ * 6) + 3)]);
    NonlinearLayer__V32(round__[((r__ * 6) + 3)],round__[((r__ * 6) + 4)]);
    BigSwap__V32(round__[((r__ * 6) + 4)],round__[((r__ * 6) + 5)]);
    NonlinearLayer__V32(round__[((r__ * 6) + 5)],round__[((r__ * 6) + 6)]);
  }
  stateR__[0][0] = round__[36][0][0];
  stateR__[0][1] = round__[36][0][1];
  stateR__[0][2] = round__[36][0][2];
  stateR__[0][3] = round__[36][0][3];
  stateR__[1][0] = round__[36][1][0];
  stateR__[1][1] = round__[36][1][1];
  stateR__[1][2] = round__[36][1][2];
  stateR__[1][3] = round__[36][1][3];
  stateR__[2][0] = round__[36][2][0];
  stateR__[2][1] = round__[36][2][1];
  stateR__[2][2] = round__[36][2][2];
  stateR__[2][3] = round__[36][2][3];

}


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

_no_inline node SPbox(col :  u32[3] :: base)
  returns colR :  u32[3] :: base
vars
  x :  u32 :: base,
  y :  u32 :: base,
  z :  u32 :: base
let
  (x) = (col[0] <<< 24);
  (y) = (col[1] <<< 9);
  (z) = col[2];
  (colR[2]) = ((x ^ (z << 1)) ^ ((y & z) << 2));
  (colR[1]) = ((y ^ x) ^ ((x | z) << 1));
  (colR[0]) = ((z ^ y) ^ ((x & y) << 3))
tel

 node NonlinearLayer(state :  u32x4[3] :: base)
  returns stateR :  u32x4[3] :: base
vars

let
  forall i in [0,3] {
    (stateR[0 .. 2][i]) = SPbox(state[0 .. 2][i])
  }
tel

 node SmallSwap(state :  u32x4[3] :: base)
  returns stateR :  u32x4[3] :: base
vars

let
  (stateR) = (state[0][1,0,3,2],state[1,2][0 .. 3])
tel

 node BigSwap(state :  u32x4[3] :: base)
  returns stateR :  u32x4[3] :: base
vars

let
  (stateR) = (state[0][2,3,0,1],state[1,2][0 .. 3])
tel

 node AddRC(state :  u32x4[3] :: base,rc :  u32 :: base)
  returns stateR :  u32x4[3] :: base
vars

let
  (stateR) = ((state[0][0] ^ rc),state[0][1 .. 3],state[1,2])
tel

 node gimli(state :  u32x4[3] :: base)
  returns stateR :  u32x4[3] :: base
vars
  rc :  u32[6] :: base,
  round :  u32x4[3][37] :: base
let
  (rc) = (2654435608,2654435604,2654435600,2654435596,2654435592,2654435588);
  (round[0]) = state;
  forall r in [0,5] {
    (round[((r * 6) + 1)]) = NonlinearLayer(round[(r * 6)])
    (round[((r * 6) + 2)]) = AddRC(SmallSwap(round[((r * 6) + 1)]),rc[r])
    (round[((r * 6) + 3)]) = NonlinearLayer(round[((r * 6) + 2)])
    (round[((r * 6) + 4)]) = NonlinearLayer(round[((r * 6) + 3)])
    (round[((r * 6) + 5)]) = BigSwap(round[((r * 6) + 4)])
    (round[((r * 6) + 6)]) = NonlinearLayer(round[((r * 6) + 5)])
  };
  (stateR) = round[36]
tel

*/
 