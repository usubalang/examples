/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/spook/usuba/ua/clyde.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */
#define NO_RUNTIME

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "STD.h"

/* auxiliary functions */
void sbox__V32 (/*inputs*/ DATATYPE x0,DATATYPE x1,DATATYPE x2,DATATYPE x3, /*outputs*/ DATATYPE* y0,DATATYPE* y1,DATATYPE* y2,DATATYPE* y3) {
  
  // Variables declaration
  DATATYPE _tmp1_;
  DATATYPE _tmp2_;
  DATATYPE _tmp3_;
  DATATYPE _tmp4_;

  // Instructions (body)
  _tmp1_ = AND(x0,x1);
  *y1 = XOR(_tmp1_,x2);
  _tmp2_ = AND(x3,x0);
  *y0 = XOR(_tmp2_,x1);
  _tmp3_ = AND(*y1,x3);
  *y3 = XOR(_tmp3_,x0);
  _tmp4_ = AND(*y0,*y1);
  *y2 = XOR(_tmp4_,x3);

}

void sbox_layer__V32 (/*inputs*/ DATATYPE x__[4], /*outputs*/ DATATYPE y__[4]) {
  
  // Variables declaration
  ;

  // Instructions (body)
  sbox__V32(x__[0],x__[1],x__[2],x__[3],&y__[0],&y__[1],&y__[2],&y__[3]);

}

void lbox__V32 (/*inputs*/ DATATYPE x__,DATATYPE y__, /*outputs*/ DATATYPE* xr__,DATATYPE* yr__) {
  
  // Variables declaration
  DATATYPE _shadow_a__1_;
  DATATYPE _shadow_a__3_;
  DATATYPE _shadow_a__5_;
  DATATYPE _shadow_a__7_;
  DATATYPE _shadow_b__2_;
  DATATYPE _shadow_b__4_;
  DATATYPE _shadow_b__6_;
  DATATYPE _shadow_b__8_;
  DATATYPE _tmp10_;
  DATATYPE _tmp11_;
  DATATYPE _tmp12_;
  DATATYPE _tmp13_;
  DATATYPE _tmp14_;
  DATATYPE _tmp15_;
  DATATYPE _tmp16_;
  DATATYPE _tmp5_;
  DATATYPE _tmp6_;
  DATATYPE _tmp7_;
  DATATYPE _tmp8_;
  DATATYPE _tmp9_;
  DATATYPE a__;
  DATATYPE b__;
  DATATYPE c__;
  DATATYPE d__;

  // Instructions (body)
  _tmp5_ = R_ROTATE(x__,12,32);
  a__ = XOR(x__,_tmp5_);
  _tmp6_ = R_ROTATE(y__,12,32);
  b__ = XOR(y__,_tmp6_);
  _tmp7_ = R_ROTATE(a__,3,32);
  _shadow_a__1_ = XOR(a__,_tmp7_);
  _tmp8_ = R_ROTATE(b__,3,32);
  _shadow_b__2_ = XOR(b__,_tmp8_);
  _tmp9_ = R_ROTATE(x__,17,32);
  _shadow_a__3_ = XOR(_shadow_a__1_,_tmp9_);
  _tmp10_ = R_ROTATE(y__,17,32);
  _shadow_b__4_ = XOR(_shadow_b__2_,_tmp10_);
  _tmp11_ = R_ROTATE(_shadow_a__3_,31,32);
  c__ = XOR(_shadow_a__3_,_tmp11_);
  _tmp12_ = R_ROTATE(_shadow_b__4_,31,32);
  d__ = XOR(_shadow_b__4_,_tmp12_);
  _tmp13_ = R_ROTATE(d__,26,32);
  _shadow_a__5_ = XOR(_shadow_a__3_,_tmp13_);
  _tmp14_ = R_ROTATE(c__,25,32);
  _shadow_b__6_ = XOR(_shadow_b__4_,_tmp14_);
  _tmp15_ = R_ROTATE(c__,15,32);
  _shadow_a__7_ = XOR(_shadow_a__5_,_tmp15_);
  _tmp16_ = R_ROTATE(d__,15,32);
  _shadow_b__8_ = XOR(_shadow_b__6_,_tmp16_);
  *xr__ = _shadow_a__7_;
  *yr__ = _shadow_b__8_;

}

void lbox_layer__V32 (/*inputs*/ DATATYPE state__[4], /*outputs*/ DATATYPE stateR__[4]) {
  
  // Variables declaration
  ;

  // Instructions (body)
  lbox__V32(state__[0],state__[1],&stateR__[0],&stateR__[1]);
  lbox__V32(state__[2],state__[3],&stateR__[2],&stateR__[3]);

}

void add_rc__V32 (/*inputs*/ DATATYPE state__[4],DATATYPE rc__[4], /*outputs*/ DATATYPE stateR__[4]) {
  
  // Variables declaration
  ;

  // Instructions (body)
  for (int i__ = 0; i__ <= 3; i__++) {
    stateR__[i__] = XOR(state__[i__],rc__[i__]);
  }

}

void tweakey__V32 (/*inputs*/ DATATYPE key__[4],DATATYPE tweak__[4], /*outputs*/ DATATYPE tk__[12]) {
  
  // Variables declaration
  DATATYPE _tmp17_[2];
  DATATYPE _tmp18_[2];
  DATATYPE _tmp19_[2];
  DATATYPE _tmp20_[2];
  DATATYPE tx__[2];

  // Instructions (body)
  tx__[0] = XOR(tweak__[0],tweak__[2]);
  tx__[1] = XOR(tweak__[1],tweak__[3]);
  tk__[0] = XOR(key__[0],tweak__[0]);
  tk__[1] = XOR(key__[1],tweak__[1]);
  tk__[2] = XOR(key__[2],tweak__[2]);
  tk__[3] = XOR(key__[3],tweak__[3]);
  _tmp17_[0] = XOR(key__[0],tx__[0]);
  _tmp17_[1] = XOR(key__[1],tx__[1]);
  _tmp18_[0] = XOR(key__[2],tweak__[0]);
  _tmp18_[1] = XOR(key__[3],tweak__[1]);
  tk__[4] = _tmp17_[0];
  tk__[5] = _tmp17_[1];
  tk__[6] = _tmp18_[0];
  tk__[7] = _tmp18_[1];
  _tmp19_[0] = XOR(key__[0],tweak__[2]);
  _tmp19_[1] = XOR(key__[1],tweak__[3]);
  _tmp20_[0] = XOR(key__[2],tx__[0]);
  _tmp20_[1] = XOR(key__[3],tx__[1]);
  tk__[8] = _tmp19_[0];
  tk__[9] = _tmp19_[1];
  tk__[10] = _tmp20_[0];
  tk__[11] = _tmp20_[1];

}

/* main function */
void clyde128__ (/*inputs*/ DATATYPE state__[4],DATATYPE key__[4],DATATYPE tweak__[4], /*outputs*/ DATATYPE cipher__[4]) {
  
  // Variables declaration
  DATATYPE _tmp21_[4];
  DATATYPE _tmp22_[4];
  DATATYPE rc__[12][4];
  DATATYPE round__[19][4];
  DATATYPE tk__[12];

  // Instructions (body)
  tweakey__V32(key__,tweak__,tk__);
  round__[0][0] = XOR(state__[0],tk__[0]);
  round__[0][1] = XOR(state__[1],tk__[1]);
  round__[0][2] = XOR(state__[2],tk__[2]);
  round__[0][3] = XOR(state__[3],tk__[3]);
  rc__[0][0] = LIFT_32(1);
  rc__[0][1] = LIFT_32(0);
  rc__[0][2] = LIFT_32(0);
  rc__[0][3] = LIFT_32(0);
  rc__[1][0] = LIFT_32(0);
  rc__[1][1] = LIFT_32(1);
  rc__[1][2] = LIFT_32(0);
  rc__[1][3] = LIFT_32(0);
  rc__[2][0] = LIFT_32(0);
  rc__[2][1] = LIFT_32(0);
  rc__[2][2] = LIFT_32(1);
  rc__[2][3] = LIFT_32(0);
  rc__[3][0] = LIFT_32(0);
  rc__[3][1] = LIFT_32(0);
  rc__[3][2] = LIFT_32(0);
  rc__[3][3] = LIFT_32(1);
  rc__[4][0] = LIFT_32(1);
  rc__[4][1] = LIFT_32(1);
  rc__[4][2] = LIFT_32(0);
  rc__[4][3] = LIFT_32(0);
  rc__[5][0] = LIFT_32(0);
  rc__[5][1] = LIFT_32(1);
  rc__[5][2] = LIFT_32(1);
  rc__[5][3] = LIFT_32(0);
  rc__[6][0] = LIFT_32(0);
  rc__[6][1] = LIFT_32(0);
  rc__[6][2] = LIFT_32(1);
  rc__[6][3] = LIFT_32(1);
  rc__[7][0] = LIFT_32(1);
  rc__[7][1] = LIFT_32(1);
  rc__[7][2] = LIFT_32(0);
  rc__[7][3] = LIFT_32(1);
  rc__[8][0] = LIFT_32(1);
  rc__[8][1] = LIFT_32(0);
  rc__[8][2] = LIFT_32(1);
  rc__[8][3] = LIFT_32(0);
  rc__[9][0] = LIFT_32(0);
  rc__[9][1] = LIFT_32(1);
  rc__[9][2] = LIFT_32(0);
  rc__[9][3] = LIFT_32(1);
  rc__[10][0] = LIFT_32(1);
  rc__[10][1] = LIFT_32(1);
  rc__[10][2] = LIFT_32(1);
  rc__[10][3] = LIFT_32(0);
  rc__[11][0] = LIFT_32(0);
  rc__[11][1] = LIFT_32(1);
  rc__[11][2] = LIFT_32(1);
  rc__[11][3] = LIFT_32(1);
  for (int s__ = 0; s__ <= 5; s__++) {
    for (int rho__ = 0; rho__ <= 1; rho__++) {
      sbox_layer__V32(round__[((s__ * 3) + rho__)],_tmp21_);
      lbox_layer__V32(_tmp21_,_tmp22_);
      add_rc__V32(_tmp22_,rc__[((s__ * 2) + rho__)],round__[(((s__ * 3) + rho__) + 1)]);
    }
    round__[((s__ + 1) * 3)][0] = XOR(round__[((s__ * 3) + 2)][0],tk__[((((s__ + 1) % 3) * 4) + 0)]);
    round__[((s__ + 1) * 3)][1] = XOR(round__[((s__ * 3) + 2)][1],tk__[((((s__ + 1) % 3) * 4) + 1)]);
    round__[((s__ + 1) * 3)][2] = XOR(round__[((s__ * 3) + 2)][2],tk__[((((s__ + 1) % 3) * 4) + 2)]);
    round__[((s__ + 1) * 3)][3] = XOR(round__[((s__ * 3) + 2)][3],tk__[((((s__ + 1) % 3) * 4) + 3)]);
  }
  cipher__[0] = round__[18][0];
  cipher__[1] = round__[18][1];
  cipher__[2] = round__[18][2];
  cipher__[3] = round__[18][3];

}


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 table sbox(x :  v4 :: base)
  returns y :  v4 :: base
{
  0, 8, 1, 15, 2, 10, 7, 9, 4, 13, 5, 6, 14, 3, 11, 12
}


_no_inline node sbox_layer(x :  v4 :: base)
  returns y :  v4 :: base
vars

let
  (y) = sbox(x)
tel

 node lbox(x :  u32 :: base,y :  u32 :: base)
  returns xr :  u32 :: base,yr :  u32 :: base
vars
  a :  u32 :: base,
  b :  u32 :: base,
  c :  u32 :: base,
  d :  u32 :: base
let
  (a) = (x ^ (x >>> 12));
  (b) = (y ^ (y >>> 12));
  (a) := (a ^ (a >>> 3));
  (b) := (b ^ (b >>> 3));
  (a) := (a ^ (x >>> 17));
  (b) := (b ^ (y >>> 17));
  (c) = (a ^ (a >>> 31));
  (d) = (b ^ (b >>> 31));
  (a) := (a ^ (d >>> 26));
  (b) := (b ^ (c >>> 25));
  (a) := (a ^ (c >>> 15));
  (b) := (b ^ (d >>> 15));
  (xr,yr) = (a,b)
tel

_no_inline node lbox_layer(state :  u32x4 :: base)
  returns stateR :  u32x4 :: base
vars

let
  (stateR[0,1]) = lbox(state[0],state[1]);
  (stateR[2,3]) = lbox(state[2],state[3])
tel

_no_inline node add_rc(state :  u32x4 :: base,rc :  u32x4 :: base)
  returns stateR :  u32x4 :: base
vars

let
  forall i in [0,3] {
    (stateR[i]) = (state[i] ^ rc[i])
  }
tel

_no_inline node tweakey(key :  u32x4 :: base,tweak :  u32x4 :: base)
  returns tk :  u32x4[3] :: base
vars
  tx :  u32[2] :: base
let
  (tx) = (tweak[0,1] ^ tweak[2,3]);
  (tk[0]) = (key ^ tweak);
  (tk[1]) = ((key[0,1] ^ tx),(key[2,3] ^ tweak[0,1]));
  (tk[2]) = ((key[0,1] ^ tweak[2,3]),(key[2,3] ^ tx))
tel

 node clyde128(state :  u32x4 :: base,key :  u32x4 :: base,tweak :  u32x4 :: base)
  returns cipher :  u32x4 :: base
vars
  rc :  u32x4[12] :: base,
  round :  u32x4[19] :: base,
  tk :  u32x4[3] :: base
let
  (rc[0]) = (1,0,0,0);
  (rc[1]) = (0,1,0,0);
  (rc[2]) = (0,0,1,0);
  (rc[3]) = (0,0,0,1);
  (rc[4]) = (1,1,0,0);
  (rc[5]) = (0,1,1,0);
  (rc[6]) = (0,0,1,1);
  (rc[7]) = (1,1,0,1);
  (rc[8]) = (1,0,1,0);
  (rc[9]) = (0,1,0,1);
  (rc[10]) = (1,1,1,0);
  (rc[11]) = (0,1,1,1);
  (tk) = tweakey(key,tweak);
  (round[0]) = (state ^ tk[0]);
  forall s in [0,5] {
    forall rho in [0,1] {
    (round[(((s * 3) + rho) + 1)]) = add_rc(lbox_layer(sbox_layer(round[((s * 3) + rho)])),rc[((s * 2) + rho)])
  }
    (round[((s + 1) * 3)]) = (round[((s * 3) + 2)] ^ tk[((s + 1) % 3)])
  };
  (cipher) = round[18]
tel

*/
 