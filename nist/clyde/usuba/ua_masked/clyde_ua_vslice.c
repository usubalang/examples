/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/clyde/usuba/ua_masked/clyde.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "MASKED.h"

/* auxiliary functions */
void sbox__V32 (/*inputs*/ DATATYPE x0__[MASKING_ORDER],DATATYPE x1__[MASKING_ORDER],DATATYPE x2__[MASKING_ORDER],DATATYPE x3__[MASKING_ORDER], /*outputs*/ DATATYPE y0__[MASKING_ORDER],DATATYPE y1__[MASKING_ORDER],DATATYPE y2__[MASKING_ORDER],DATATYPE y3__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp1_[MASKING_ORDER];
  DATATYPE _tmp2_[MASKING_ORDER];
  DATATYPE _tmp3_[MASKING_ORDER];
  DATATYPE _tmp4_[MASKING_ORDER];

  // Instructions (body)
  AND(_tmp1_,x0__,x1__);
  XOR(y1__,_tmp1_,x2__);
  AND(_tmp2_,x3__,x0__);
  XOR(y0__,_tmp2_,x1__);
  AND(_tmp3_,y1__,x3__);
  XOR(y3__,_tmp3_,x0__);
  AND(_tmp4_,y0__,y1__);
  XOR(y2__,_tmp4_,x3__);

}

void sbox_R__V32 (/*inputs*/ DATATYPE x0__[MASKING_ORDER],DATATYPE x1__[MASKING_ORDER],DATATYPE x2__[MASKING_ORDER],DATATYPE x3__[MASKING_ORDER], /*outputs*/ DATATYPE y0__[MASKING_ORDER],DATATYPE y1__[MASKING_ORDER],DATATYPE y2__[MASKING_ORDER],DATATYPE y3__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp5_[MASKING_ORDER];
  DATATYPE _tmp6_[MASKING_ORDER];
  DATATYPE _tmp7_[MASKING_ORDER];
  DATATYPE _tmp8_[MASKING_ORDER];
  DATATYPE y1_R__[MASKING_ORDER];

  // Instructions (body)
  AND(_tmp5_,x0__,x1__);
  XOR(y1__,_tmp5_,x2__);
  REFRESH(y1_R__,y1__);
  AND(_tmp6_,x3__,x0__);
  XOR(y0__,_tmp6_,x1__);
  AND(_tmp7_,y1_R__,x3__);
  XOR(y3__,_tmp7_,x0__);
  AND(_tmp8_,y0__,y1_R__);
  XOR(y2__,_tmp8_,x3__);

}

void lbox__V32 (/*inputs*/ DATATYPE x__[MASKING_ORDER],DATATYPE y__[MASKING_ORDER], /*outputs*/ DATATYPE xr__[MASKING_ORDER],DATATYPE yr__[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_a__1_[MASKING_ORDER];
  DATATYPE _shadow_a__3_[MASKING_ORDER];
  DATATYPE _shadow_a__5_[MASKING_ORDER];
  DATATYPE _shadow_a__7_[MASKING_ORDER];
  DATATYPE _shadow_b__2_[MASKING_ORDER];
  DATATYPE _shadow_b__4_[MASKING_ORDER];
  DATATYPE _shadow_b__6_[MASKING_ORDER];
  DATATYPE _shadow_b__8_[MASKING_ORDER];
  DATATYPE _tmp10_[MASKING_ORDER];
  DATATYPE _tmp11_[MASKING_ORDER];
  DATATYPE _tmp12_[MASKING_ORDER];
  DATATYPE _tmp13_[MASKING_ORDER];
  DATATYPE _tmp14_[MASKING_ORDER];
  DATATYPE _tmp15_[MASKING_ORDER];
  DATATYPE _tmp16_[MASKING_ORDER];
  DATATYPE _tmp17_[MASKING_ORDER];
  DATATYPE _tmp18_[MASKING_ORDER];
  DATATYPE _tmp19_[MASKING_ORDER];
  DATATYPE _tmp20_[MASKING_ORDER];
  DATATYPE _tmp9_[MASKING_ORDER];
  DATATYPE a__[MASKING_ORDER];
  DATATYPE b__[MASKING_ORDER];
  DATATYPE c__[MASKING_ORDER];
  DATATYPE d__[MASKING_ORDER];

  // Instructions (body)
  R_ROTATE(_tmp9_,x__,12,32);
  XOR(a__,x__,_tmp9_);
  R_ROTATE(_tmp10_,y__,12,32);
  XOR(b__,y__,_tmp10_);
  R_ROTATE(_tmp11_,a__,3,32);
  XOR(_shadow_a__1_,a__,_tmp11_);
  R_ROTATE(_tmp12_,b__,3,32);
  XOR(_shadow_b__2_,b__,_tmp12_);
  R_ROTATE(_tmp13_,x__,17,32);
  XOR(_shadow_a__3_,_shadow_a__1_,_tmp13_);
  R_ROTATE(_tmp14_,y__,17,32);
  XOR(_shadow_b__4_,_shadow_b__2_,_tmp14_);
  R_ROTATE(_tmp15_,_shadow_a__3_,31,32);
  XOR(c__,_shadow_a__3_,_tmp15_);
  R_ROTATE(_tmp16_,_shadow_b__4_,31,32);
  XOR(d__,_shadow_b__4_,_tmp16_);
  R_ROTATE(_tmp17_,d__,26,32);
  XOR(_shadow_a__5_,_shadow_a__3_,_tmp17_);
  R_ROTATE(_tmp18_,c__,25,32);
  XOR(_shadow_b__6_,_shadow_b__4_,_tmp18_);
  R_ROTATE(_tmp19_,c__,15,32);
  XOR(_shadow_a__7_,_shadow_a__5_,_tmp19_);
  R_ROTATE(_tmp20_,d__,15,32);
  XOR(_shadow_b__8_,_shadow_b__6_,_tmp20_);
  ASGN(xr__,_shadow_a__7_);
  ASGN(yr__,_shadow_b__8_);

}

void lbox_layer__V32 (/*inputs*/ DATATYPE state__[4][MASKING_ORDER], /*outputs*/ DATATYPE stateR__[4][MASKING_ORDER]) {

  // Variables declaration
  ;

  // Instructions (body)
  lbox__V32(state__[0],state__[1],stateR__[0],stateR__[1]);
  lbox__V32(state__[2],state__[3],stateR__[2],stateR__[3]);

}

void add_rc__V32 (/*inputs*/ DATATYPE state__[4][MASKING_ORDER],DATATYPE rc__[4][MASKING_ORDER], /*outputs*/ DATATYPE stateR__[4][MASKING_ORDER]) {

  // Variables declaration
  ;

  // Instructions (body)
  for (int i__ = 0; i__ <= 3; i__++) {
    XOR(stateR__[i__],state__[i__],rc__[i__]);
  }

}

void tweakey__V32 (/*inputs*/ DATATYPE key__[4][MASKING_ORDER],DATATYPE tweak__[4][MASKING_ORDER], /*outputs*/ DATATYPE tk__[3][4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp21_[2][MASKING_ORDER];
  DATATYPE _tmp22_[2][MASKING_ORDER];
  DATATYPE _tmp23_[2][MASKING_ORDER];
  DATATYPE _tmp24_[2][MASKING_ORDER];
  DATATYPE tx__[2][MASKING_ORDER];

  // Instructions (body)
  XOR(tx__[0],tweak__[0],tweak__[2]);
  XOR(tx__[1],tweak__[1],tweak__[3]);
  XOR(tk__[0][0],key__[0],tweak__[0]);
  XOR(tk__[0][1],key__[1],tweak__[1]);
  XOR(tk__[0][2],key__[2],tweak__[2]);
  XOR(tk__[0][3],key__[3],tweak__[3]);
  XOR(_tmp21_[0],key__[0],tx__[0]);
  XOR(_tmp21_[1],key__[1],tx__[1]);
  XOR(_tmp22_[0],key__[2],tweak__[0]);
  XOR(_tmp22_[1],key__[3],tweak__[1]);
  ASGN(tk__[1][0],_tmp21_[0]);
  ASGN(tk__[1][1],_tmp21_[1]);
  ASGN(tk__[1][2],_tmp22_[0]);
  ASGN(tk__[1][3],_tmp22_[1]);
  XOR(_tmp23_[0],key__[0],tweak__[2]);
  XOR(_tmp23_[1],key__[1],tweak__[3]);
  XOR(_tmp24_[0],key__[2],tx__[0]);
  XOR(_tmp24_[1],key__[3],tx__[1]);
  ASGN(tk__[2][0],_tmp23_[0]);
  ASGN(tk__[2][1],_tmp23_[1]);
  ASGN(tk__[2][2],_tmp24_[0]);
  ASGN(tk__[2][3],_tmp24_[1]);

}

/* main function */
void clyde128__ (/*inputs*/ DATATYPE state__[4][MASKING_ORDER],DATATYPE key__[4][MASKING_ORDER],DATATYPE tweak__[4][MASKING_ORDER], /*outputs*/ DATATYPE cipher__[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp73_[4][MASKING_ORDER];
  DATATYPE _tmp74_[4][MASKING_ORDER];
  DATATYPE _tmp75_[4][MASKING_ORDER];
  DATATYPE _tmp76_[4][MASKING_ORDER];
  DATATYPE rc__[12][4][MASKING_ORDER];
  DATATYPE round__[4][MASKING_ORDER];
  DATATYPE tk__[3][4][MASKING_ORDER];

  // Instructions (body)
  ASGN_CST(rc__[0][0], LIFT_32(1));
  ASGN_CST(rc__[0][1], LIFT_32(0));
  ASGN_CST(rc__[0][2], LIFT_32(0));
  ASGN_CST(rc__[0][3], LIFT_32(0));
  ASGN_CST(rc__[1][0], LIFT_32(0));
  ASGN_CST(rc__[1][1], LIFT_32(1));
  ASGN_CST(rc__[1][2], LIFT_32(0));
  ASGN_CST(rc__[1][3], LIFT_32(0));
  ASGN_CST(rc__[2][0], LIFT_32(0));
  ASGN_CST(rc__[2][1], LIFT_32(0));
  ASGN_CST(rc__[2][2], LIFT_32(1));
  ASGN_CST(rc__[2][3], LIFT_32(0));
  ASGN_CST(rc__[3][0], LIFT_32(0));
  ASGN_CST(rc__[3][1], LIFT_32(0));
  ASGN_CST(rc__[3][2], LIFT_32(0));
  ASGN_CST(rc__[3][3], LIFT_32(1));
  ASGN_CST(rc__[4][0], LIFT_32(1));
  ASGN_CST(rc__[4][1], LIFT_32(1));
  ASGN_CST(rc__[4][2], LIFT_32(0));
  ASGN_CST(rc__[4][3], LIFT_32(0));
  ASGN_CST(rc__[5][0], LIFT_32(0));
  ASGN_CST(rc__[5][1], LIFT_32(1));
  ASGN_CST(rc__[5][2], LIFT_32(1));
  ASGN_CST(rc__[5][3], LIFT_32(0));
  ASGN_CST(rc__[6][0], LIFT_32(0));
  ASGN_CST(rc__[6][1], LIFT_32(0));
  ASGN_CST(rc__[6][2], LIFT_32(1));
  ASGN_CST(rc__[6][3], LIFT_32(1));
  ASGN_CST(rc__[7][0], LIFT_32(1));
  ASGN_CST(rc__[7][1], LIFT_32(1));
  ASGN_CST(rc__[7][2], LIFT_32(0));
  ASGN_CST(rc__[7][3], LIFT_32(1));
  ASGN_CST(rc__[8][0], LIFT_32(1));
  ASGN_CST(rc__[8][1], LIFT_32(0));
  ASGN_CST(rc__[8][2], LIFT_32(1));
  ASGN_CST(rc__[8][3], LIFT_32(0));
  ASGN_CST(rc__[9][0], LIFT_32(0));
  ASGN_CST(rc__[9][1], LIFT_32(1));
  ASGN_CST(rc__[9][2], LIFT_32(0));
  ASGN_CST(rc__[9][3], LIFT_32(1));
  ASGN_CST(rc__[10][0], LIFT_32(1));
  ASGN_CST(rc__[10][1], LIFT_32(1));
  ASGN_CST(rc__[10][2], LIFT_32(1));
  ASGN_CST(rc__[10][3], LIFT_32(0));
  ASGN_CST(rc__[11][0], LIFT_32(0));
  ASGN_CST(rc__[11][1], LIFT_32(1));
  ASGN_CST(rc__[11][2], LIFT_32(1));
  ASGN_CST(rc__[11][3], LIFT_32(1));
  tweakey__V32(key__,tweak__,tk__);
  XOR(round__[0],state__[0],tk__[0][0]);
  XOR(round__[1],state__[1],tk__[0][1]);
  XOR(round__[2],state__[2],tk__[0][2]);
  XOR(round__[3],state__[3],tk__[0][3]);
  for (int s__ = 0; s__ <= 5; s__++) {
    sbox_R__V32(round__[0],round__[1],round__[2],round__[3],_tmp73_[0],_tmp73_[1],_tmp73_[2],_tmp73_[3]);
    lbox_layer__V32(_tmp73_,_tmp74_);
    add_rc__V32(_tmp74_,rc__[(s__ * 2)],round__);
    sbox__V32(round__[0],round__[1],round__[2],round__[3],_tmp75_[0],_tmp75_[1],_tmp75_[2],_tmp75_[3]);
    lbox_layer__V32(_tmp75_,_tmp76_);
    add_rc__V32(_tmp76_,rc__[((s__ * 2) + 1)],round__);
    XOR(round__[0],round__[0],tk__[((s__ + 1) % 3)][0]);
    XOR(round__[1],round__[1],tk__[((s__ + 1) % 3)][1]);
    XOR(round__[2],round__[2],tk__[((s__ + 1) % 3)][2]);
    XOR(round__[3],round__[3],tk__[((s__ + 1) % 3)][3]);
  }
  ASGN(cipher__[0],round__[0]);
  ASGN(cipher__[1],round__[1]);
  ASGN(cipher__[2],round__[2]);
  ASGN(cipher__[3],round__[3]);

}

/* Additional functions */


/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

_inline node sbox(x0 :  v1 :: base,x1 :  v1 :: base,x2 :  v1 :: base,x3 :  v1 :: base)
  returns y0 :  v1 :: base,y1 :  v1 :: base,y2 :  v1 :: base,y3 :  v1 :: base
vars

let
  (y1) = ((x0 & x1) ^ x2);
  (y0) = ((x3 & x0) ^ x1);
  (y3) = ((y1 & x3) ^ x0);
  (y2) = ((y0 & y1) ^ x3)
tel

_inline node sbox_R(x0 :  v1 :: base,x1 :  v1 :: base,x2 :  v1 :: base,x3 :  v1 :: base)
  returns y0 :  v1 :: base,y1 :  v1 :: base,y2 :  v1 :: base,y3 :  v1 :: base
vars
  y1_R :  v1 :: base
let
  (y1) = ((x0 & x1) ^ x2);
  (y1_R) = refresh(y1);
  (y0) = ((x3 & x0) ^ x1);
  (y3) = ((y1_R & x3) ^ x0);
  (y2) = ((y0 & y1_R) ^ x3)
tel

_inline node lbox(x :  u32 :: base,y :  u32 :: base)
  returns xr :  u32 :: base,yr :  u32 :: base
vars
  a :  u32 :: base,
  b :  u32 :: base,
  c :  u32 :: base,
  d :  u32 :: base
let
  (a) = (x ^ (x >>> 12));
  (b) = (y ^ (y >>> 12));
  (a) := (a ^ (a >>> 3));
  (b) := (b ^ (b >>> 3));
  (a) := (a ^ (x >>> 17));
  (b) := (b ^ (y >>> 17));
  (c) = (a ^ (a >>> 31));
  (d) = (b ^ (b >>> 31));
  (a) := (a ^ (d >>> 26));
  (b) := (b ^ (c >>> 25));
  (a) := (a ^ (c >>> 15));
  (b) := (b ^ (d >>> 15));
  (xr,yr) = (a,b)
tel

_no_inline node lbox_layer(state :  u32x4 :: base)
  returns stateR :  u32x4 :: base
vars

let
  (stateR[0,1]) = lbox(state[0],state[1]);
  (stateR[2,3]) = lbox(state[2],state[3])
tel

_no_inline node add_rc(state :  u32x4 :: base,rc :  u32x4 :: base)
  returns stateR :  u32x4 :: base
vars

let
  forall i in [0,3] {
    (stateR[i]) = (state[i] ^ rc[i])
  }
tel

_no_inline node tweakey(key :  u32x4 :: base,tweak :  u32x4 :: base)
  returns tk :  u32x4[3] :: base
vars
  tx :  u32[2] :: base
let
  (tx) = (tweak[0,1] ^ tweak[2,3]);
  (tk[0]) = (key ^ tweak);
  (tk[1]) = ((key[0,1] ^ tx),(key[2,3] ^ tweak[0,1]));
  (tk[2]) = ((key[0,1] ^ tweak[2,3]),(key[2,3] ^ tx))
tel

 node clyde128(state :  u32x4 :: base,key :  u32x4 :: base,tweak :  u32x4 :: base)
  returns cipher :  u32x4 :: base
vars
  rc :  u32x4[12] :: base,
  round :  u32x4[19] :: base,
  tk :  u32x4[3] :: base
let
  (rc[0]) = (1,0,0,0);
  (rc[1]) = (0,1,0,0);
  (rc[2]) = (0,0,1,0);
  (rc[3]) = (0,0,0,1);
  (rc[4]) = (1,1,0,0);
  (rc[5]) = (0,1,1,0);
  (rc[6]) = (0,0,1,1);
  (rc[7]) = (1,1,0,1);
  (rc[8]) = (1,0,1,0);
  (rc[9]) = (0,1,0,1);
  (rc[10]) = (1,1,1,0);
  (rc[11]) = (0,1,1,1);
  (tk) = tweakey(key,tweak);
  (round[0]) = (state ^ tk[0]);
  forall s in [0,5] {
    (round[((s * 3) + 1)]) = add_rc(lbox_layer(sbox_R(round[(s * 3)])),rc[(s * 2)]);
    (round[((s * 3) + 2)]) = add_rc(lbox_layer(sbox(round[((s * 3) + 1)])),rc[((s * 2) + 1)]);
    (round[((s * 3) + 3)]) = (round[((s * 3) + 2)] ^ tk[((s + 1) % 3)])
  };
  (cipher) = round[18]
tel

*/
 