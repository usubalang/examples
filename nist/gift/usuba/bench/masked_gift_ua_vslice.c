/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "nist/gift/usuba/ua/gift.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */

#ifndef BITS_PER_REG
#define BITS_PER_REG 32
#endif
/* including the architecture specific .h */
#include "MASKED.h"

/* auxiliary functions */
void SubCells__V32 (/*inputs*/ DATATYPE S0__[MASKING_ORDER],DATATYPE S1__[MASKING_ORDER],DATATYPE S2__[MASKING_ORDER],DATATYPE S3__[MASKING_ORDER], /*outputs*/ DATATYPE S____[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _shadow_S0__2_[MASKING_ORDER];
  DATATYPE _shadow_S1__1_[MASKING_ORDER];
  DATATYPE _shadow_S1__5_[MASKING_ORDER];
  DATATYPE _shadow_S2__3_[MASKING_ORDER];
  DATATYPE _shadow_S2__7_[MASKING_ORDER];
  DATATYPE _shadow_S3__4_[MASKING_ORDER];
  DATATYPE _shadow_S3__6_[MASKING_ORDER];
  DATATYPE _tmp1_[MASKING_ORDER];
  DATATYPE _tmp2_[MASKING_ORDER];
  DATATYPE _tmp3_[MASKING_ORDER];
  DATATYPE _tmp4_[MASKING_ORDER];

  // Instructions (body)
  AND(_tmp1_,S0__,S2__);
  XOR(_shadow_S1__1_,S1__,_tmp1_);
  AND(_tmp2_,_shadow_S1__1_,S3__);
  XOR(_shadow_S0__2_,S0__,_tmp2_);
  OR(_tmp3_,_shadow_S0__2_,_shadow_S1__1_);
  XOR(_shadow_S2__3_,S2__,_tmp3_);
  XOR(_shadow_S3__4_,S3__,_shadow_S2__3_);
  XOR(_shadow_S1__5_,_shadow_S1__1_,_shadow_S3__4_);
  NOT(_shadow_S3__6_,_shadow_S3__4_);
  AND(_tmp4_,_shadow_S0__2_,_shadow_S1__5_);
  XOR(_shadow_S2__7_,_shadow_S2__3_,_tmp4_);
  ASGN(S____[0],_shadow_S3__6_);
  ASGN(S____[1],_shadow_S1__5_);
  ASGN(S____[2],_shadow_S2__7_);
  ASGN(S____[3],_shadow_S0__2_);

}

void rowperm__V_Natnat_32 (/*inputs*/ DATATYPE S__[MASKING_ORDER],unsigned int B0_pos__,unsigned int B1_pos__,unsigned int B2_pos__,unsigned int B3_pos__, /*outputs*/ DATATYPE S____[MASKING_ORDER]) {

  // Variables declaration
  DATATYPE T__[MASKING_ORDER];
  DATATYPE _tmp10_[MASKING_ORDER];
  DATATYPE _tmp12_[MASKING_ORDER];
  DATATYPE _tmp13_[MASKING_ORDER];
  DATATYPE _tmp14_[MASKING_ORDER];
  DATATYPE _tmp15_[MASKING_ORDER];
  DATATYPE _tmp17_[MASKING_ORDER];
  DATATYPE _tmp18_[MASKING_ORDER];
  DATATYPE _tmp19_[MASKING_ORDER];
  DATATYPE _tmp20_[MASKING_ORDER];
  DATATYPE _tmp22_[MASKING_ORDER];
  DATATYPE _tmp23_[MASKING_ORDER];
  DATATYPE _tmp5_[MASKING_ORDER];
  DATATYPE _tmp7_[MASKING_ORDER];
  DATATYPE _tmp8_[MASKING_ORDER];
  DATATYPE _tmp9_[MASKING_ORDER];
  DATATYPE _tmp99_[MASKING_ORDER];
  DATATYPE _tmp98_[MASKING_ORDER];
  DATATYPE _tmp97_[MASKING_ORDER];
  DATATYPE _tmp96_[MASKING_ORDER];

  // Instructions (body)
  ASGN_CST(T__, LIFT_32(0));
  for (int b__ = 0; b__ <= 7; b__++) {
    R_SHIFT(_tmp5_,S__,((4 * b__) + 0),32);
    ASGN_CST(_tmp96_, LIFT_32(1));
    AND_CST(_tmp7_,_tmp5_,_tmp96_);
    L_SHIFT(_tmp8_,_tmp7_,(b__ + (8 * B0_pos__)),32);
    XOR_CST(_tmp9_,_tmp8_,T__);
    R_SHIFT(_tmp10_,S__,((4 * b__) + 1),32);
    ASGN_CST(_tmp97_, LIFT_32(1));
    AND_CST(_tmp12_,_tmp10_,_tmp97_);
    L_SHIFT(_tmp13_,_tmp12_,(b__ + (8 * B1_pos__)),32);
    XOR(_tmp14_,_tmp9_,_tmp13_);
    R_SHIFT(_tmp15_,S__,((4 * b__) + 2),32);
    ASGN_CST(_tmp98_, LIFT_32(1));
    AND_CST(_tmp17_,_tmp15_,_tmp98_);
    L_SHIFT(_tmp18_,_tmp17_,(b__ + (8 * B2_pos__)),32);
    XOR(_tmp19_,_tmp14_,_tmp18_);
    R_SHIFT(_tmp20_,S__,((4 * b__) + 3),32);
    ASGN_CST(_tmp99_, LIFT_32(1));
    AND_CST(_tmp22_,_tmp20_,_tmp99_);
    L_SHIFT(_tmp23_,_tmp22_,(b__ + (8 * B3_pos__)),32);
    XOR(T__,_tmp19_,_tmp23_);
  }
  ASGN(S____,T__);

}

void PermBits__V32 (/*inputs*/ DATATYPE S__[4][MASKING_ORDER], /*outputs*/ DATATYPE S____[4][MASKING_ORDER]) {

  // Variables declaration
  unsigned int _tmp115_;
  unsigned int _tmp114_;
  unsigned int _tmp113_;
  unsigned int _tmp112_;
  unsigned int _tmp111_;
  unsigned int _tmp110_;
  unsigned int _tmp109_;
  unsigned int _tmp108_;
  unsigned int _tmp107_;
  unsigned int _tmp106_;
  unsigned int _tmp105_;
  unsigned int _tmp104_;
  unsigned int _tmp103_;
  unsigned int _tmp102_;
  unsigned int _tmp101_;
  unsigned int _tmp100_;

  // Instructions (body)
  _tmp100_ = 0;
  _tmp101_ = 3;
  _tmp102_ = 2;
  _tmp103_ = 1;
  rowperm__V_Natnat_32(S__[0],_tmp100_,_tmp101_,_tmp102_,_tmp103_,S____[0]);
  _tmp104_ = 1;
  _tmp105_ = 0;
  _tmp106_ = 3;
  _tmp107_ = 2;
  rowperm__V_Natnat_32(S__[1],_tmp104_,_tmp105_,_tmp106_,_tmp107_,S____[1]);
  _tmp108_ = 2;
  _tmp109_ = 1;
  _tmp110_ = 0;
  _tmp111_ = 3;
  rowperm__V_Natnat_32(S__[2],_tmp108_,_tmp109_,_tmp110_,_tmp111_,S____[2]);
  _tmp112_ = 3;
  _tmp113_ = 2;
  _tmp114_ = 1;
  _tmp115_ = 0;
  rowperm__V_Natnat_32(S__[3],_tmp112_,_tmp113_,_tmp114_,_tmp115_,S____[3]);

}

void AddRoundKey__V32 (/*inputs*/ DATATYPE S__[4][MASKING_ORDER],DATATYPE W__[8][MASKING_ORDER],DATATYPE rc__[MASKING_ORDER], /*outputs*/ DATATYPE S____[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp40_[MASKING_ORDER];
  DATATYPE _tmp41_[MASKING_ORDER];
  DATATYPE _tmp42_[MASKING_ORDER];
  DATATYPE _tmp43_[MASKING_ORDER];
  DATATYPE _tmp45_[MASKING_ORDER];
  DATATYPE _tmp116_[MASKING_ORDER];

  // Instructions (body)
  L_SHIFT(_tmp40_,W__[2],16,32);
  XOR(_tmp41_,_tmp40_,W__[3]);
  XOR(S____[2],S__[2],_tmp41_);
  L_SHIFT(_tmp42_,W__[6],16,32);
  XOR(_tmp43_,_tmp42_,W__[7]);
  XOR(S____[1],S__[1],_tmp43_);
  ASGN_CST(_tmp116_, LIFT_32(2147483648));
  XOR_CST(_tmp45_,S__[3],_tmp116_);
  XOR(S____[3],_tmp45_,rc__);
  ASGN(S____[0],S__[0]);

}

void KeyUpdate__V32 (/*inputs*/ DATATYPE W__[8][MASKING_ORDER], /*outputs*/ DATATYPE W____[8][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE _tmp46_[MASKING_ORDER];
  DATATYPE _tmp47_[MASKING_ORDER];
  DATATYPE _tmp48_[MASKING_ORDER];
  DATATYPE _tmp50_[MASKING_ORDER];
  DATATYPE _tmp51_[MASKING_ORDER];
  DATATYPE _tmp52_[MASKING_ORDER];
  DATATYPE _tmp118_[MASKING_ORDER];
  DATATYPE _tmp117_[MASKING_ORDER];

  // Instructions (body)
  R_SHIFT(_tmp46_,W__[6],2,32);
  L_SHIFT(_tmp47_,W__[6],14,32);
  XOR(_tmp48_,_tmp46_,_tmp47_);
  ASGN_CST(_tmp117_, LIFT_32(65535));
  AND_CST(W____[0],_tmp48_,_tmp117_);
  R_SHIFT(_tmp50_,W__[7],12,32);
  L_SHIFT(_tmp51_,W__[7],4,32);
  XOR(_tmp52_,_tmp50_,_tmp51_);
  ASGN_CST(_tmp118_, LIFT_32(65535));
  AND_CST(W____[1],_tmp52_,_tmp118_);
  ASGN(W____[7],W__[5]);
  ASGN(W____[6],W__[4]);
  ASGN(W____[5],W__[3]);
  ASGN(W____[4],W__[2]);
  ASGN(W____[3],W__[1]);
  ASGN(W____[2],W__[0]);

}

/* main function */
void gift__ (/*inputs*/ DATATYPE P__[4][MASKING_ORDER],DATATYPE K__[8][MASKING_ORDER], /*outputs*/ DATATYPE C__[4][MASKING_ORDER]) {

  // Variables declaration
  DATATYPE GIFT_RC__[40][MASKING_ORDER];
  DATATYPE W__[41][8][MASKING_ORDER];
  DATATYPE _tmp94_[4][MASKING_ORDER];
  DATATYPE _tmp95_[4][MASKING_ORDER];
  DATATYPE round__[4][MASKING_ORDER];

  // Instructions (body)
  ASGN(round__[0],P__[0]);
  ASGN(round__[1],P__[1]);
  ASGN(round__[2],P__[2]);
  ASGN(round__[3],P__[3]);
  ASGN(W__[0][0],K__[0]);
  ASGN(W__[0][1],K__[1]);
  ASGN(W__[0][2],K__[2]);
  ASGN(W__[0][3],K__[3]);
  ASGN(W__[0][4],K__[4]);
  ASGN(W__[0][5],K__[5]);
  ASGN(W__[0][6],K__[6]);
  ASGN(W__[0][7],K__[7]);
  ASGN_CST(GIFT_RC__[0], LIFT_32(1));
  ASGN_CST(GIFT_RC__[1], LIFT_32(3));
  ASGN_CST(GIFT_RC__[2], LIFT_32(7));
  ASGN_CST(GIFT_RC__[3], LIFT_32(15));
  ASGN_CST(GIFT_RC__[4], LIFT_32(31));
  ASGN_CST(GIFT_RC__[5], LIFT_32(62));
  ASGN_CST(GIFT_RC__[6], LIFT_32(61));
  ASGN_CST(GIFT_RC__[7], LIFT_32(59));
  ASGN_CST(GIFT_RC__[8], LIFT_32(55));
  ASGN_CST(GIFT_RC__[9], LIFT_32(47));
  ASGN_CST(GIFT_RC__[10], LIFT_32(30));
  ASGN_CST(GIFT_RC__[11], LIFT_32(60));
  ASGN_CST(GIFT_RC__[12], LIFT_32(57));
  ASGN_CST(GIFT_RC__[13], LIFT_32(51));
  ASGN_CST(GIFT_RC__[14], LIFT_32(39));
  ASGN_CST(GIFT_RC__[15], LIFT_32(14));
  ASGN_CST(GIFT_RC__[16], LIFT_32(29));
  ASGN_CST(GIFT_RC__[17], LIFT_32(58));
  ASGN_CST(GIFT_RC__[18], LIFT_32(53));
  ASGN_CST(GIFT_RC__[19], LIFT_32(43));
  ASGN_CST(GIFT_RC__[20], LIFT_32(22));
  ASGN_CST(GIFT_RC__[21], LIFT_32(44));
  ASGN_CST(GIFT_RC__[22], LIFT_32(24));
  ASGN_CST(GIFT_RC__[23], LIFT_32(48));
  ASGN_CST(GIFT_RC__[24], LIFT_32(33));
  ASGN_CST(GIFT_RC__[25], LIFT_32(2));
  ASGN_CST(GIFT_RC__[26], LIFT_32(5));
  ASGN_CST(GIFT_RC__[27], LIFT_32(11));
  ASGN_CST(GIFT_RC__[28], LIFT_32(23));
  ASGN_CST(GIFT_RC__[29], LIFT_32(46));
  ASGN_CST(GIFT_RC__[30], LIFT_32(28));
  ASGN_CST(GIFT_RC__[31], LIFT_32(56));
  ASGN_CST(GIFT_RC__[32], LIFT_32(49));
  ASGN_CST(GIFT_RC__[33], LIFT_32(35));
  ASGN_CST(GIFT_RC__[34], LIFT_32(6));
  ASGN_CST(GIFT_RC__[35], LIFT_32(13));
  ASGN_CST(GIFT_RC__[36], LIFT_32(27));
  ASGN_CST(GIFT_RC__[37], LIFT_32(54));
  ASGN_CST(GIFT_RC__[38], LIFT_32(45));
  ASGN_CST(GIFT_RC__[39], LIFT_32(26));
  for (int i__ = 0; i__ <= 39; i__++) {
    SubCells__V32(round__[0],round__[1],round__[2],round__[3],_tmp94_);
    PermBits__V32(_tmp94_,_tmp95_);
    AddRoundKey__V32(_tmp95_,W__[i__],GIFT_RC__[i__],round__);
    KeyUpdate__V32(W__[i__],W__[(i__ + 1)]);
  }
  ASGN(C__[0],round__[0]);
  ASGN(C__[1],round__[1]);
  ASGN(C__[2],round__[2]);
  ASGN(C__[3],round__[3]);

}

/* Additional functions */
uint32_t bench_speed() {
  /* inputs */
  DATATYPE P__[4][MASKING_ORDER] = { 0 };
  DATATYPE K__[8][MASKING_ORDER] = { 0 };
  /* outputs */
  DATATYPE C__[4][MASKING_ORDER] = { 0 };
  /* fun call */
  gift__(P__, K__,C__);

  /* Returning the number of encrypted bytes */
  return 16;
}

/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

 node SubCells(S0 :  v1 :: base,S1 :  v1 :: base,S2 :  v1 :: base,S3 :  v1 :: base)
  returns S' :  v4 :: base
vars

let
  (S1) := (S1 ^ (S0 & S2));
  (S0) := (S0 ^ (S1 & S3));
  (S2) := (S2 ^ (S0 | S1));
  (S3) := (S3 ^ S2);
  (S1) := (S1 ^ S3);
  (S3) := (~ S3);
  (S2) := (S2 ^ (S0 & S1));
  (S') = (S3,S1,S2,S0)
tel

 node rowperm(S :  u32 :: base,B0_pos :  nat :: base,B1_pos :  nat :: base,B2_pos :  nat :: base,B3_pos :  nat :: base)
  returns S' :  u32 :: base
vars
  T :  u32[9] :: base
let
  (T[0]) = 0;
  forall b in [0,7] {
    (T[(b + 1)]) = ((((T[b] ^ (((S >> ((4 * b) + 0)) & 1) << (b + (8 * B0_pos)))) ^ (((S >> ((4 * b) + 1)) & 1) << (b + (8 * B1_pos)))) ^ (((S >> ((4 * b) + 2)) & 1) << (b + (8 * B2_pos)))) ^ (((S >> ((4 * b) + 3)) & 1) << (b + (8 * B3_pos))))
  };
  (S') = T[8]
tel

 node PermBits(S :  u32x4 :: base)
  returns S' :  u32x4 :: base
vars

let
  (S'[0]) = rowperm(S[0],0,3,2,1);
  (S'[1]) = rowperm(S[1],1,0,3,2);
  (S'[2]) = rowperm(S[2],2,1,0,3);
  (S'[3]) = rowperm(S[3],3,2,1,0)
tel

 node AddRoundKey(S :  u32x4 :: base,W :  u32[8] :: base,rc :  u32 :: base)
  returns S' :  u32x4 :: base
vars

let
  (S'[2]) = (S[2] ^ ((W[2] << 16) ^ W[3]));
  (S'[1]) = (S[1] ^ ((W[6] << 16) ^ W[7]));
  (S'[3]) = ((S[3] ^ 2147483648) ^ rc);
  (S'[0]) = S[0]
tel

 node KeyUpdate(W :  u32[8] :: base)
  returns W' :  u32[8] :: base
vars

let
  (W'[0]) = (((W[6] >> 2) ^ (W[6] << 14)) & 65535);
  (W'[1]) = (((W[7] >> 12) ^ (W[7] << 4)) & 65535);
  (W'[7 .. 2]) = W[5 .. 0]
tel

 node gift(P :  u32x4 :: base,K : const u32[8] :: base)
  returns C :  u32x4 :: base
vars
  round :  u32x4[41] :: base,
  W :  u32[41][8] :: base,
  GIFT_RC :  u32[40] :: base
let
  (round[0]) = P;
  (W[0]) = K;
  (GIFT_RC) = (1,3,7,15,31,62,61,59,55,47,30,60,57,51,39,14,29,58,53,43,22,44,24,48,33,2,5,11,23,46,28,56,49,35,6,13,27,54,45,26);
  forall i in [0,39] {
    (round[(i + 1)]) = AddRoundKey(PermBits(SubCells(round[i])),W[i],GIFT_RC[i]);
    (W[(i + 1)]) = KeyUpdate(W[i])
  };
  (C) = round[40]
tel

*/
 