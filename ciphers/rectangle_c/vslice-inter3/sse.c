/* This code was generated by Usuba.
   See https://github.com/DadaIsCrazy/usuba.
   From the file "samples/usuba/rectangle_vector.ua" (included below). */

#include <stdint.h>

/* Do NOT change the order of those define/include */
#define NO_RUNTIME
#ifndef BITS_PER_REG
#define BITS_PER_REG 128
#endif
/* including the architecture specific .h */
#include "SSE.h"

/* auxiliary functions */
void SubColumn__ (/*inputs*/ DATATYPE a0,DATATYPE a0__2,DATATYPE a0__3,DATATYPE a1,DATATYPE a1__2,DATATYPE a1__3,DATATYPE a2,DATATYPE a2__2,DATATYPE a2__3,DATATYPE a3,DATATYPE a3__2,DATATYPE a3__3, /*outputs*/ DATATYPE* b0,DATATYPE* b0__2,DATATYPE* b0__3,DATATYPE* b1,DATATYPE* b1__2,DATATYPE* b1__3,DATATYPE* b2,DATATYPE* b2__2,DATATYPE* b2__3,DATATYPE* b3,DATATYPE* b3__2,DATATYPE* b3__3) {
  
  // Variables declaration
  DATATYPE t1;
  DATATYPE t11;
  DATATYPE t11__2;
  DATATYPE t1__2;
  DATATYPE t11__3;
  DATATYPE t1__3;
  DATATYPE t2;
  DATATYPE t2__2;
  DATATYPE t2__3;
  DATATYPE t3;
  DATATYPE t3__2;
  DATATYPE t3__3;
  DATATYPE t5;
  DATATYPE t5__2;
  DATATYPE t5__3;
  DATATYPE t6;
  DATATYPE t6__2;
  DATATYPE t6__3;
  DATATYPE t8;
  DATATYPE t8__2;
  DATATYPE t8__3;
  DATATYPE t9;
  DATATYPE t9__2;
  DATATYPE t9__3;

  // Instructions (body)
  t1 = NOT(a1);
  t3 = XOR(a2,a3);
  t8 = XOR(a1,a2);
  t1__2 = NOT(a1__2);
  t3__2 = XOR(a2__2,a3__2);
  t8__2 = XOR(a1__2,a2__2);
  t1__3 = NOT(a1__3);
  t3__3 = XOR(a2__3,a3__3);
  t8__3 = XOR(a1__3,a2__3);
  t2 = AND(a0,t1);
  t5 = OR(a3,t1);
  t2__2 = AND(a0__2,t1__2);
  t5__2 = OR(a3__2,t1__2);
  t2__3 = AND(a0__3,t1__3);
  t5__3 = OR(a3__3,t1__3);
  *b0 = XOR(t2,t3);
  t6 = XOR(a0,t5);
  *b0__2 = XOR(t2__2,t3__2);
  t6__2 = XOR(a0__2,t5__2);
  *b0__3 = XOR(t2__3,t3__3);
  t6__3 = XOR(a0__3,t5__3);
  t11 = OR(*b0,t8);
  *b1 = XOR(a2,t6);
  t9 = AND(t3,t6);
  t11__2 = OR(*b0__2,t8__2);
  *b1__2 = XOR(a2__2,t6__2);
  t9__2 = AND(t3__2,t6__2);
  t11__3 = OR(*b0__3,t8__3);
  *b1__3 = XOR(a2__3,t6__3);
  t9__3 = AND(t3__3,t6__3);
  *b2 = XOR(t6,t11);
  *b3 = XOR(t8,t9);
  *b2__2 = XOR(t6__2,t11__2);
  *b3__2 = XOR(t8__2,t9__2);
  *b2__3 = XOR(t6__3,t11__3);
  *b3__3 = XOR(t8__3,t9__3);

}

/* main function */
void Rectangle__ (/*inputs*/ DATATYPE plain__[4],DATATYPE plain____2[4],DATATYPE plain____3[4],uint16_t key__[26][4], /*outputs*/ DATATYPE cipher__[4],DATATYPE cipher____2[4],DATATYPE cipher____3[4]) {
  
  // Variables declaration
  DATATYPE _tmp1_[4];
  DATATYPE _tmp1___2[4];
  DATATYPE _tmp1___3[4];
  DATATYPE tmp__[4];
  DATATYPE tmp____2[4];
  DATATYPE tmp____3[4];

  // Instructions (body)
  tmp__[0] = plain__[0];
  tmp__[1] = plain__[1];
  tmp__[2] = plain__[2];
  tmp__[3] = plain__[3];
  tmp____2[0] = plain____2[0];
  tmp____2[1] = plain____2[1];
  tmp____2[2] = plain____2[2];
  tmp____2[3] = plain____2[3];
  tmp____3[0] = plain____3[0];
  tmp____3[1] = plain____3[1];
  tmp____3[2] = plain____3[2];
  tmp____3[3] = plain____3[3];
  for (int i = 0; i <= 24; i++) {
    _tmp1_[0] = XOR(tmp__[0],LIFT_16(key__[i][0]));
    _tmp1_[1] = XOR(tmp__[1],LIFT_16(key__[i][1]));
    _tmp1_[2] = XOR(tmp__[2],LIFT_16(key__[i][2]));
    _tmp1_[3] = XOR(tmp__[3],LIFT_16(key__[i][3]));
    _tmp1___2[0] = XOR(tmp____2[0],LIFT_16(key__[i][0]));
    _tmp1___2[1] = XOR(tmp____2[1],LIFT_16(key__[i][1]));
    _tmp1___2[2] = XOR(tmp____2[2],LIFT_16(key__[i][2]));
    _tmp1___2[3] = XOR(tmp____2[3],LIFT_16(key__[i][3]));
    _tmp1___3[0] = XOR(tmp____3[0],LIFT_16(key__[i][0]));
    _tmp1___3[1] = XOR(tmp____3[1],LIFT_16(key__[i][1]));
    _tmp1___3[2] = XOR(tmp____3[2],LIFT_16(key__[i][2]));
    _tmp1___3[3] = XOR(tmp____3[3],LIFT_16(key__[i][3]));
    SubColumn__(_tmp1_[0],_tmp1___2[0],_tmp1___3[0],_tmp1_[1],_tmp1___2[1],_tmp1___3[1],_tmp1_[2],_tmp1___2[2],_tmp1___3[2],_tmp1_[3],_tmp1___2[3],_tmp1___3[3],&_tmp1_[0],&_tmp1___2[0],&_tmp1___3[0],&_tmp1_[1],&_tmp1___2[1],&_tmp1___3[1],&_tmp1_[2],&_tmp1___2[2],&_tmp1___3[2],&_tmp1_[3],&_tmp1___2[3],&_tmp1___3[3]);
    tmp__[0] = _tmp1_[0];
    tmp__[1] = L_ROTATE(_tmp1_[1],1,16);
    tmp__[2] = L_ROTATE(_tmp1_[2],12,16);
    tmp__[3] = L_ROTATE(_tmp1_[3],13,16);
    tmp____2[0] = _tmp1___2[0];
    tmp____2[1] = L_ROTATE(_tmp1___2[1],1,16);
    tmp____2[2] = L_ROTATE(_tmp1___2[2],12,16);
    tmp____2[3] = L_ROTATE(_tmp1___2[3],13,16);
    tmp____3[0] = _tmp1___3[0];
    tmp____3[1] = L_ROTATE(_tmp1___3[1],1,16);
    tmp____3[2] = L_ROTATE(_tmp1___3[2],12,16);
    tmp____3[3] = L_ROTATE(_tmp1___3[3],13,16);
  }
  cipher__[0] = XOR(tmp__[0],LIFT_16(key__[25][0]));
  cipher__[1] = XOR(tmp__[1],LIFT_16(key__[25][1]));
  cipher__[2] = XOR(tmp__[2],LIFT_16(key__[25][2]));
  cipher__[3] = XOR(tmp__[3],LIFT_16(key__[25][3]));
  cipher____2[0] = XOR(tmp____2[0],LIFT_16(key__[25][0]));
  cipher____2[1] = XOR(tmp____2[1],LIFT_16(key__[25][1]));
  cipher____2[2] = XOR(tmp____2[2],LIFT_16(key__[25][2]));
  cipher____2[3] = XOR(tmp____2[3],LIFT_16(key__[25][3]));
  cipher____3[0] = XOR(tmp____3[0],LIFT_16(key__[25][0]));
  cipher____3[1] = XOR(tmp____3[1],LIFT_16(key__[25][1]));
  cipher____3[2] = XOR(tmp____3[2],LIFT_16(key__[25][2]));
  cipher____3[3] = XOR(tmp____3[3],LIFT_16(key__[25][3]));

}



/* **************************************************************** */
/*                            Usuba source                          */
/*                                                                  */
/*

_no_inline table SubColumn(input :  u16x4 :: base)
  returns out :  u16x4 :: base
{
  6, 5, 12, 10, 1, 14, 7, 9, 11, 0, 3, 13, 8, 15, 4, 2
}


 node ShiftRows(input :  u16x4 :: base)
  returns out :  u16x4 :: base
vars

let
  (out[0]) = input[0];
  (out[1]) = (input[1] <<< 1);
  (out[2]) = (input[2] <<< 12);
  (out[3]) = (input[3] <<< 13)
tel

 node Rectangle(plain :  u16x4 :: base,key : const u16x4[26] :: base)
  returns cipher :  u16x4 :: base
vars
  tmp :  u16x4[26] :: base
let
  (tmp[0]) = plain;
  _no_unroll forall i in [0,24] {
    (tmp[(i + 1)]) = ShiftRows(SubColumn((tmp[i] ^ key[i])))
  };
  (cipher) = (tmp[25] ^ key[25])
tel

*/
 
